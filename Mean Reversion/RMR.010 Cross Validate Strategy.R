#' ---
#' title: "Cross Validate Strategy"
#' author: "Kevin Lu"
#' date: '`r format(Sys.Date(), "%B %d, %Y")`'
#' output: 
#'   html_document: 
#'     theme: default 
#'     highlight: tango
#'     toc: true 
#'     toc_float: true
#'     number_sections: false
#'     fig_width: 8 
#'     fig_height: 5 
#' ---

#' # 1. Load Packages 
source("./Mean Reversion/RMR.001 Load Packages.R")

#' # 2. Load Data 
pricing_data <- read_csv("./Mean Reversion/Raw Data/pricing data clean.csv")

#' # 3. Subset and Spread Data Function 
#' Description  
#' Spreads Poloneix pricing data into wide format and filters data to a specified time resolution and time window. 
#' 
#' Arguments  
#' df: A dataframe containing pricing data from Poloneix gathered in tidy format.  
#' time_resolution: The number of seconds that each observation spans. Takes values 300, 900, 1800, 7200, 14400, and 86400.  
#' start_date: The start date of the time window.  
#' end_date: The end date of the time window.  
prepare_data <- function(df, time_resolution, start_date, end_date) { 
  df <- df %>% 
    filter(period == time_resolution, 
           date_time >= start_date, 
           date_time <= end_date) %>% 
    select(date_unix, date_time, close, currency_pair) %>% 
    spread(currency_pair, close) 
  return(df)
} 

#' # 4. Select Coin Pairs 
#' Description  
#' Select coin pairs trading logic goes here. Currently a placeholder.  
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair. 
select_pairs <- function(train) { 
  print("This is a placeholder.")
}

#' # 5. Generate Signals 
#' Description  
#' Generate trading signals that indicate the current position in the spread formed by a linear combination of 
#' coin y and coin x. A signal of +1 indicates a long position in the spread, 0 indicates a flat position, and 
#' -1 indicates a short position in the spread. Signals are generated for the test set using a model trained on 
#' the training set.  
#' 
#' The current trading logic is perform a linear regression of coin y on coin x using the training set. A spread is
#' then calculated in the test set using the fitted hedge ratio and intercept from the regression. The z-score of the 
#' spread is then calculated using the mean and standard deviation of the training set. A long position is entered 
#' when the z-score falls below -2 and the position is closed when the z-score returns to 0. A short position is 
#' entered when the z-score rises above +2 and the position is closed when the z-score returns to 0. 
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair. 
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pair. 
#' coin_y: A string indicating the dependent coin in the coin pair regression. 
#' coin_x: A string indicating the independent coin in the coin pair regression. 
generate_signals <- function(train, test, coin_y, coin_x) { 
  model <- lm(train[[coin_y]] ~ train[[coin_x]]) 
  intercept <- coef(model)[1] 
  hedge_ratio <- coef(model)[2] 
  df_signals <- test %>% 
    mutate(spread = test[[coin_y]] - test[[coin_x]] * hedge_ratio - intercept, 
           spread_z = (spread - mean(model[["residuals"]])) / sd(model[["residuals"]]), 
           signal_long = ifelse(lag(spread_z, 1) <= -2, 1, NA), 
           signal_long = ifelse(lag(spread_z, 1) >= 0, 0, signal_long), 
           signal_long = na.locf(signal_long, na.rm = FALSE), 
           signal_short = ifelse(lag(spread_z, 1) >= 2, -1, NA), 
           signal_short = ifelse(lag(spread_z, 1) <= 0, 0, signal_short), 
           signal_short = na.locf(signal_short, na.rm = FALSE), 
           signal = signal_long + signal_short, 
           signal = ifelse(is.na(signal), 0, signal)) 
  return(df_signals[["signal"]])
}

#' # 6. Perform Backtest 
#' Description  
#' Calculate the return of a cointegration-based mean reversion trading strategy using coin y and coin x. 
#' 
#' The current backtesting logic uses signals generated by generate_signals(). The coin_y_return and 
#' coin_x_return indicate the one period percentage return of each coin. The coin_y_position and 
#' coin_x_position indicate the market value in USD in each coin. coin_y_pnl and coin_x_pnl indicate 
#' the USD value of the profit and loss for each coin. The combined_position indicates the gross market 
#' value of the combined positions. 
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair. 
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pair. 
#' coin_y: A string indicating the dependent coin in the coin pair regression. 
#' coin_x: A string indicating the independent coin in the coin pair regression. 
perform_backtest <- function(train, test, coin_y, coin_x) { 
  model <- lm(train[[coin_y]] ~ train[[coin_x]]) 
  intercept <- coef(model)[1] 
  hedge_ratio <- coef(model)[2] 
  df_backtest <- test %>% 
    mutate(signal = generate_signals(train, test, coin_y, coin_x), 
           coin_y_return = test[[coin_y]] / lag(test[[coin_y]]) - 1, 
           coin_x_return = test[[coin_x]] / lag(test[[coin_x]]) - 1, 
           coin_y_position = test[[coin_y]] * signal * 1, 
           coin_x_position = test[[coin_x]] * signal * hedge_ratio * -1,  
           coin_y_pnl = lag(coin_y_position, 1) * coin_y_return, 
           coin_x_pnl = lag(coin_x_position, 1) * coin_x_return, 
           combined_position = abs(coin_y_position) + abs(coin_x_position), 
           combined_pnl = coin_y_pnl + coin_x_pnl, 
           combined_return = combined_pnl / lag(combined_position, 1)) %>% 
    mutate_all(funs(ifelse(is.na(.), 0, .))) %>%
    mutate(date_time = as.POSIXct(date_unix, origin = "1970-01-01"), 
           return_model = cumprod(1 + combined_return)) 
  return(df_backtest[["return_model"]])
} 

#' # 7. Plot Backtest 
plot_backtest <- function(train, test, coin_y, coin_x) { 
  model <- lm(train[[coin_y]] ~ train[[coin_x]]) 
  intercept <- coef(model)[1] 
  hedge_ratio <- coef(model)[2] 
  df_plot <- test %>% 
    mutate(spread = test[[coin_y]] - test[[coin_x]] * hedge_ratio - intercept, 
           spread_z = (spread - mean(model[["residuals"]])) / sd(model[["residuals"]]), 
           signal = generate_signals(train, test, coin_y, coin_x), 
           return_model = perform_backtest(train, test, coin_y, coin_x))
  print(ggplot(df_plot, aes(x = date_time)) + 
          geom_line(aes(y = spread_z), size = 1, colour = "blue") + 
          geom_hline(yintercept = 0, colour = "red", alpha = 0.5) + 
          geom_hline(yintercept = 2, colour = "red", alpha = 0.5) + 
          geom_hline(yintercept = -2, colour = "red", alpha = 0.5) + 
          geom_line(aes(y = signal), colour = "green", alpha = 0.5))
  print(ggplot(df_plot, aes(x = date_time)) + 
          geom_line(aes(y = return_model), size = 1, colour = "blue") + 
          geom_hline(yintercept = 1, colour = "black", alpha = 0.5))
}


#' # 8. Split Into Train and Test Sets 
train <- prepare_data(df = pricing_data, time_resolution = 7200, start_date = "2017-07-01", end_date = "2017-09-01")
test <- prepare_data(df = pricing_data, time_resolution = 7200, start_date = "2017-09-01", end_date = "2017-09-30")
print(train)
print(test)

#' # 9. Backtest Some Coins 
plot_backtest(train, test, "USDT_XMR", "USDT_LTC")
plot_backtest(train, test, "USDT_LTC", "USDT_XMR")
plot_backtest(train, test, "BTC_ETH", "BTC_DASH")
plot_backtest(train, test, "USDT_REP", "USDT_BTC")
plot_backtest(train, test, "USDT_XEM", "USDT_LTC")
