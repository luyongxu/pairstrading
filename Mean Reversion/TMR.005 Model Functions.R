#' ---
#' title: "Cross Validate Strategy"
#' author: "Kevin Lu"
#' date: '`r format(Sys.Date(), "%B %d, %Y")`'
#' output: 
#'   html_document: 
#'     theme: default 
#'     highlight: tango
#'     toc: true 
#'     toc_float: true
#'     number_sections: false
#'     fig_width: 8 
#'     fig_height: 5 
#' --- 

#' # 1. Load Packages 
source("./Mean Reversion/TMR.001 Load Packages.R") 

#' # 2. Train Model Function 
#' Description   
#' Performs a linear regression of coin y on coin x over the test set. The regression can be rolling or fixed, can 
#' take raw or log prices, and can use either ols, tls, or a non-parametric regression method.    
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair.  
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pair.  
#' coin_y: A string indicating the dependent coin in the coin pair regression.  
#' coin_x: A string indicating the independent coin in the coin pair regression.  
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy.  
#'   rolling_window: The number of observations used in the loobkack window of a rolling linear regression.  
#'   model_type: A string indicating whether raw prices or log prices should be used. Takes value "raw" or "log". 
#'   spread_type: A string indicating whether the regression uses a rolling or fixed window. Takes value "rolling" or "fixed".  
#'   regression_type: A string indicating whether OLS, TLS, or a non-parametric regression should be used. 
#'     Takes values "ols", "tls", and "non-parametric". 
#' 
#' Value  
#' Returns a list containing the intercept, hedge ratio, spread, and spread z-score calculated from a regression 
#' over the test set. If the spread type is fixed, the intercept and hedge ratio are just single numbers. If the 
#' spread type is rolling, the intercept and hedge ratio are a vector with length equal to the test set.  
train_model <- function(train, test, coin_y, coin_x, params) { 
  
  # Use either raw or log prices
  if (params[["model_type"]] == "raw") { 
    train[[coin_y]] <- train[[coin_y]] 
    train[[coin_x]] <- train[[coin_x]] 
    test[[coin_y]] <- test[[coin_y]] 
    test[[coin_x]] <- test[[coin_x]] 
  } 
  if (params[["model_type"]] == "log" & params[["regression_type"]] != "non-parametric") { 
    train[[coin_y]] <- log(train[[coin_y]]) 
    train[[coin_x]] <- log(train[[coin_x]]) 
    test[[coin_y]] <- log(test[[coin_y]]) 
    test[[coin_x]] <- log(test[[coin_x]]) 
  } 
  
  # If calculation of spread uses a rolling regression 
  if (params[["spread_type"]] == "rolling") { 
    
    # Prepare data in a format where rollapply can be used 
    rolling_coef <- bind_rows(train, test) %>%  
      mutate(y = .[[coin_y]], 
             x = .[[coin_x]]) %>% 
      select(y, x)

    # Perform rolling linear regression over the test set if regression type is OLS 
    if (params[["regression_type"]] == "ols") { 
      rolling_coef <- rolling_coef %>% 
        rollapply(data = ., width = params[["rolling_window"]], FUN = function(df) { 
                    df <- as_tibble(df)
                    lm_model <- lm.fit(y = df[["y"]], x = cbind(1, df[["x"]]))
                    return(lm_model[["coefficients"]])
                  }, by.column = FALSE, fill = NA, align = "right") %>% 
        as_tibble() %>% 
        rename(intercept = x1, 
               hedge_ratio = x2) %>% 
        filter(row_number() > nrow(train)) 
    } 
    
    # Perform rolling linear regression over the test set if regression type is TLS
    if (params[["regression_type"]] == "tls") { 
      rolling_coef <- rolling_coef %>% 
        rollapply(data = ., width = params[["rolling_window"]], FUN = function(df) { 
                    df <- as_tibble(df) 
                    pca_model <- prcomp(x = cbind(df[["y"]], df[["x"]]))  
                    pca_beta <- pca_model[["rotation"]][1, 1] / pca_model[["rotation"]][2, 1] 
                    pca_intercept <- pca_model[["center"]][1] - pca_beta * pca_model[["center"]][2] 
                    return(tibble(intercept = pca_intercept, hedge_ratio = pca_beta))
                  }, by.column = FALSE, fill = NA, align = "right") %>% 
        as_tibble() %>% 
        filter(row_number() > nrow(train)) 
    } 
    
    # Calculate spread in training and test set if spread type is rolling and regression type is OLS. 
    # Over the training set, the spread is the residuals from a regression using all the observations in the training set. 
    # Over the test set, the spread is calculated using fitted coefficients from a rolling regression. 
    if (params[["regression_type"]] == "ols") { 
      train <- train %>% 
        mutate(spread = lm.fit(y = train[[coin_y]], x = cbind(1, train[[coin_x]]))[["residuals"]])
      test <- test %>% 
        mutate(spread = test[[coin_y]] - test[[coin_x]] * rolling_coef[["hedge_ratio"]] - rolling_coef[["intercept"]]) 
    }
    
    # Calculate spread in training and test set if spread type is rolling and regression type is TLS  
    if (params[["regression_type"]] == "tls") { 
      pca_model <- prcomp(formula = ~ train[[coin_y]] + train[[coin_x]]) 
      pca_beta <- pca_model[["rotation"]][1, 1] / pca_model[["rotation"]][2, 1] 
      pca_intercept <- pca_model[["center"]][1] - pca_beta * pca_model[["center"]][2] 
      train <- train %>% 
        mutate(spread = train[[coin_y]] - train[[coin_x]] * pca_beta - pca_intercept) 
      test <- test %>% 
        mutate(spread = test[[coin_y]] - test[[coin_x]] * rolling_coef[["hedge_ratio"]] - rolling_coef[["intercept"]]) 
    } 
    
    # Combine train and test to calculate rolling z-score for the test set  
    if (params[["regression_type"]] == "ols" | params[["regression_type"]] == "tls") { 
      result <- bind_rows(train %>% mutate(source = "train"), 
                          test %>% mutate(source = "test")) %>% 
        mutate(rolling_mean = roll_mean(spread, n = params[["rolling_window"]], fill = NA, align = "right"), 
               rolling_sd = roll_sd(spread, n = params[["rolling_window"]], fill = NA, align = "right"), 
               spread_z = (spread - rolling_mean) / rolling_sd) %>% 
        filter(source == "test") 
    }
    
    # Calculate spread in training and test set if regression type is non-parametric 
    # Calculates normalized prices using a rolling a window and defines the spread as the difference betewen the normalized 
    # prices. For backtesting position calculation purposes, set the intercept and hedge ratio to 1.  
    if (params[["regression_type"]] == "non-parametric") { 
      combined <- bind_rows(train %>% mutate(source == "train"), 
                            test %>% mutate(source == "test")) %>%   
        mutate(coin_y_normalized = .[[coin_y]] / lag(.[[coin_y]], params[["rolling_window"]]), 
               coin_x_normalized = .[[coin_x]] / lag(.[[coin_x]], params[["rolling_window"]]), 
               sd = roll_sdr(coin_y_normalized - coin_x_normalized, n = params[["rolling_window"]]), 
               spread = coin_y_normalized - coin_x_normalized, 
               spread_z = spread / sd) %>% 
        filter(source == "test")
      rolling_coef[["intercept"]] <- 0 
      rolling_coef[["hedge_ratio"]] <- 1 
    } 
    
    # Return list of statistics for the test set if the spread type is rolling  
    return(list(intercept = rolling_coef[["intercept"]], 
                hedge_ratio = rolling_coef[["hedge_ratio"]], 
                spread = result[["spread"]], 
                spread_z = result[["spread_z"]]))
  } 
  
  # If calculation of spread uses a model with fixed coefficients estimated over the training set 
  if (params[["spread_type"]] == "fixed") { 
    
    # If spread type is fixed regression uses OLS 
    if (params[["regression_type"]] == "ols") { 
      model <- lm.fit(y = train[[coin_y]], x = cbind(1, train[[coin_x]])) 
      intercept <- coef(model)[1] 
      hedge_ratio <- coef(model)[2] 
      result <- test %>% 
        mutate(spread = test[[coin_y]] - test[[coin_x]] * hedge_ratio - intercept, 
               spread_z = (spread - mean(model[["residuals"]])) / sd(model[["residuals"]]))
    }
    
    # If spread type is fixed and regression uses TLS 
    if (params[["regression_type"]] == "tls") { 
      pca_model <- prcomp(formula = ~ train[[coin_y]] + train[[coin_x]]) 
      intercept <- pca_model[["center"]][1] - pca_beta * pca_model[["center"]][2]
      hedge_ratio <- pca_model[["rotation"]][1, 1] / pca_model[["rotation"]][2, 1] 
      pca_residuals <- train[[coin_y]] - hedge_ratio * train[[coin_x]] - intercept 
      result <- test %>% 
        mutate(spread = test[[coin_y]] - test[[coin_x]] * hedge_ratio - intercept, 
               spread_z = (spread - mean(pca_residuals)) / sd(pca_residuals))
    } 
    
    # If spread type is fixed and model is non-parametric 
    if (params[["regression_type"]] == "non-parametric") { 
      train <- train %>% 
        mutate(coin_y_normalized = train[[coin_y]] / train[[coin_y]][1], 
               coin_x_normalized = train[[coin_x]] / train[[coin_x]][1], 
               spread = coin_y_normalized - coin_x_normalized) 
      result <- test %>% 
        mutate(coin_y_normalized = test[[coin_y]] / test[[coin_y]][1], 
               coin_x_normalized = test[[coin_x]] / test[[coin_x]][1], 
               spread = coin_y_normalized - coin_x_normalized, 
               spread_z = spread / sd(train[["spread"]]))
      intercept = 0
      hedge_ratio = 1 
    } 
    
    # Return list of statistics for the test set if the spread type is fixed  
    return(list(intercept = intercept, 
                hedge_ratio = hedge_ratio, 
                spread = result[["spread"]], 
                spread_z = result[["spread_z"]]))
  }
} 

#' # 3. Generate Signals Function 
#' Description  
#' Generate trading signals that indicate the current position in the spread formed by a trained model generated by  
#' train_model(). The trained model generates the spread and z-score of the spread over the test set. A signal of +1 
#' indicates a long position in the spread, 0 indicates a flat position, and -1 indicates a short position in the 
#' spread. 
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair.  
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pair.  
#' coin_y: A string indicating the dependent coin in the coin pair regression.  
#' coin_x: A string indicating the independent coin in the coin pair regression.  
#' model: A trained model generated by train_model(). 
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy.  
#'   signal_logic: A string indicating which logic to use to generate signals. Takes values "scaled" or "discrete".   
#'   signal_scaled_enter: The z-score threshold indicating the z-score that the signal is fully scaled in when the 
#'     signal logic is scaled.  
#'   signal_discrete_enter: The z-score threshold for entering a position when the signal logic is discrete.   
#'   signal_discrete_exit: The z-score threshold for exiting a position when the signal logic is discrete.  
#'   signal_stop: A threshold for the spread z-score beyond which the strategy stops trading the coin pair. 
#'   signal_reenter: A boolean indicating whether the strategy should reenter positions after exceeding the 
#'     signal_stop threshold once the spread z-score returns to a reasonable range.    
#'   signal_reenter_threshold: The z-score threshold for reentering a position if signal_reenter is TRUE. 
#' 
#' Value  
#' Returns a vector containing the trading signal over the test set.  
generate_signals <- function(train, test, coin_y, coin_x, model, params) { 
  
  # Scaled signal logic in which signal can take continuous values depending on the spread z-score
  if (params[["signal_logic"]] == "scaled") { 
    
    # Create signal strength depending on signal_scaled_enter parameter. Creates a signal strength vector 
    # that represents the signal at every increment in the spread z-score below.  
    if (params[["signal_scaled_enter"]] == 2.0) ss <- c(0.25, 0.50, 0.75, 1.00, 1.00, 1.00, 1.00, 1.00, 1.00)
    if (params[["signal_scaled_enter"]] == 3.0) ss <- c(0.33, 0.33, 0.67, 0.67, 1.00, 1.00, 1.00, 1.00, 1.00)
    if (params[["signal_scaled_enter"]] == 4.0) ss <- c(0.25, 0.25, 0.50, 0.50, 0.75, 1.00, 1.00, 1.00, 1.00)
    
    # calculate signal 
    df_signals <- test %>% 
      mutate(spread = model[["spread"]], 
             spread_z = model[["spread_z"]], 
             lag_spread_z = lag(spread_z, 1, default = 0), 
             signal_long = if_else(lag_spread_z <=  0.0 & lag_spread_z > -0.5, ss[1], 0), 
             signal_long = if_else(lag_spread_z <= -0.5 & lag_spread_z > -1.0, ss[2], signal_long), 
             signal_long = if_else(lag_spread_z <= -1.0 & lag_spread_z > -1.5, ss[3], signal_long), 
             signal_long = if_else(lag_spread_z <= -1.5 & lag_spread_z > -2.0, ss[4], signal_long), 
             signal_long = if_else(lag_spread_z <= -2.0 & lag_spread_z > -3.0, ss[5], signal_long), 
             signal_long = if_else(lag_spread_z <= -3.0 & lag_spread_z > -4.0, ss[6], signal_long), 
             signal_long = if_else(lag_spread_z <= -4.0 & lag_spread_z > -5.0, ss[7], signal_long), 
             signal_long = if_else(lag_spread_z <= -5.0 & lag_spread_z > -6.0, ss[8], signal_long), 
             signal_long = if_else(lag_spread_z <= -6.0 & lag_spread_z > -7.0, ss[9], signal_long), 
             signal_long = if_else(lag_spread_z <= -params[["signal_stop"]], 0, signal_long), 
             signal_short = if_else(lag_spread_z >= 0.0 & lag_spread_z < 0.5, -ss[1], 0), 
             signal_short = if_else(lag_spread_z >= 0.5 & lag_spread_z < 1.0, -ss[2], signal_short), 
             signal_short = if_else(lag_spread_z >= 1.0 & lag_spread_z < 1.5, -ss[3], signal_short), 
             signal_short = if_else(lag_spread_z >= 1.5 & lag_spread_z < 2.0, -ss[4], signal_short), 
             signal_short = if_else(lag_spread_z >= 2.0 & lag_spread_z < 3.0, -ss[5], signal_short), 
             signal_short = if_else(lag_spread_z >= 3.0 & lag_spread_z < 4.0, -ss[6], signal_short), 
             signal_short = if_else(lag_spread_z >= 4.0 & lag_spread_z < 5.0, -ss[7], signal_short), 
             signal_short = if_else(lag_spread_z >= 5.0 & lag_spread_z < 6.0, -ss[8], signal_short), 
             signal_short = if_else(lag_spread_z >= 6.0 & lag_spread_z < 7.0, -ss[9], signal_short), 
             signal_short = if_else(lag_spread_z >= params[["signal_stop"]], 0, signal_short), 
             signal = signal_long + signal_short)
  } 
  
  # Discrete signal logic in which signal can only take discrete values depending on the spread z-score 
  if (params[["signal_logic"]] == "discrete") { 
    
    df_signals <- test %>% 
      mutate(spread = model[["spread"]], 
             spread_z = model[["spread_z"]], 
             lag_spread_z = lag(spread_z, 1, default = 0), 
             signal_long = if_else(lag_spread_z <= -params[["signal_discrete_enter"]], 1, NA_real_), 
             signal_long = if_else(lag_spread_z >= -params[["signal_discrete_exit"]] , 0, signal_long), 
             signal_long = if_else(lag_spread_z <= -params[["signal_stop"]], 0, signal_long), 
             signal_long = na.locf(signal_long, na.rm = FALSE), 
             signal_short = if_else(lag_spread_z >= params[["signal_discrete_enter"]], -1, NA_real_), 
             signal_short = if_else(lag_spread_z <= params[["signal_discrete_exit"]], 0, signal_short), 
             signal_short = if_else(lag_spread_z >= params[["signal_stop"]], 0, signal_short), 
             signal_short = na.locf(signal_short, na.rm = FALSE), 
             signal = signal_long + signal_short) 
  } 
  
  # Set signal stopping logic. If signal_reenter is FALSE, the strategy permanently exits the pair if 
  # the stop loss threshold is reached. 
  if (params[["signal_reenter"]] == FALSE) { 
    df_signals <- df_signals %>% 
      mutate(signal = if_else(is.na(signal), 0, signal), 
             signal = if_else(cummin(lag_spread_z) <= -params[["signal_stop"]], 0, signal), 
             signal = if_else(cummax(lag_spread_z) >=  params[["signal_stop"]], 0, signal))
  } 
  
  # If signal_reenter is TRUE, the strategy reenters the pair if the spread z-score returns to a reasonable level. 
  if (params[["signal_reenter"]] == TRUE) { 
    df_signals <- df_signals %>% 
      mutate(reenter = if_else(cummax(abs(lag_spread_z)) >= params[["signal_stop"]] & 
                                 abs(lag_spread_z) <= params[["signal_reenter_threshold"]], 
                               TRUE, NA), 
             reenter = na.locf(reenter, na.rm = FALSE), 
             signal = if_else(is.na(signal), 0, signal), 
             signal = if_else(cummin(lag_spread_z) <= -params[["signal_stop"]] & is.na(reenter), 0, signal), 
             signal = if_else(cummax(lag_spread_z) >=  params[["signal_stop"]] & is.na(reenter), 0, signal))   
  } 
  
  # Return signal over test set 
  return(df_signals[["signal"]])
} 
