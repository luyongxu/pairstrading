#' ---
#' title: "Plot Functions"
#' author: "Kevin Lu"
#' date: '`r format(Sys.Date(), "%B %d, %Y")`'
#' output: 
#'   html_document: 
#'     theme: default 
#'     highlight: tango
#'     toc: true 
#'     toc_float: true
#'     number_sections: false
#'     fig_width: 8 
#'     fig_height: 5 
#' --- 

#' # 1. Load Packages 
source("./src/util/01-load-packages.R")

#' # 2. Plot Single Function 
#' Description  
#' Create plots of a cointegration-based mean reversion trading strategy of a single coin pair comprised of 
#' coin y and coin x. There are two plots created by this function. The first plot displays the spread transformed 
#' into z-score with three red lines at -2, 0, and 2. A green line indicates the signal which can take values -1, 
#' 0, and +1. The second plot displays the cumulative return of the model in blue. Two additional lines show the buy 
#' and hold return of coin y and coin x as red and green lines, respectively. 
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair.  
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pair.  
#' coin_y: A string indicating the dependent coin in the coin pair regression.  
#' coin_x: A string indicating the independent coin in the coin pair regression. 
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy.  
#' print: A boolean indicating whether to print the plots or return the plots as a list. 
#' 
#' Value  
#' Prints the plots or returns a list of plots.   
plot_single <- function(train, test, coin_y, coin_x, params, print) { 
  
  # Generate model for calculating spread z-score 
  model <- train_model(train = train, 
                       test = test, 
                       coin_y = coin_y, 
                       coin_x = coin_x, 
                       params = params) 
  
  # Calculate prices for coins and beginning and ending dates over the train and test sets
  df_plot_a <- backtest_pair(train = train, 
                           test = test, 
                           coin_y = coin_y, 
                           coin_x = coin_x, 
                           params = params) 
  df_dates <- df_plot_a %>% 
    group_by(source) %>% 
    summarise(start = min(date_time), 
              end = max(date_time)) 
  df_index <- df_plot_a %>% 
    filter(source == "train") %>% 
    filter(row_number() == n())
  
  # Calculate signal and strategy return for the coin pair over the test set  
  df_plot_b <- test %>% 
    mutate(spread = model[["spread"]], 
           spread_z = model[["spread_z"]], 
           intercept = model[["intercept"]], 
           hedge_ratio = model[["hedge_ratio"]], 
           signal = generate_signals(train = train, 
                                     test = test, 
                                     coin_y = coin_y, 
                                     coin_x = coin_x, 
                                     model = model, 
                                     params = params), 
           return_pair = df_plot_a %>% filter(source == "test") %>% .[["cumulative_return"]], 
           return_buyhold_y = test[[coin_y]] / test[[coin_y]][1], 
           return_buyhold_x = test[[coin_x]] / test[[coin_x]][1]) 
  
  # Calculate intercept and hedge ratio for the model over the test set 
  df_plot_c <- df_plot_b %>% 
    select(date_time, intercept, hedge_ratio) %>% 
    gather(data = ., key = "parameter", value = "value", intercept, hedge_ratio) %>% 
    mutate(parameter = ifelse(parameter == "intercept", "Intercept", parameter), 
           parameter = ifelse(parameter == "hedge_ratio", "Hedge Ratio", parameter))
  
  # Calculate average 24-hour return and annualized sharpe ratio
  df_plot_d <- df_plot_a %>% 
    filter(source == "test") 
  label_return <- exp(mean(log(1 + df_plot_d[["combined_return"]]))) ^ (86400 / as.numeric(params[["time_resolution"]])) - 1
  label_sharpe <- ((exp(mean(log(1 + df_plot_d[["combined_return"]]))) - 1) / 
    sd(df_plot_d[["combined_return"]])) * ((86400 * 252 / as.numeric(params[["time_resolution"]]))^0.5)
  label_subtitle <- str_c(coin_y, " and ", coin_x, ". Average return of model (24h): ", percent(label_return), ". ", 
                          "Annualized sharpe ratio: ", round(label_sharpe, 2), ".") 
  
  # This plot plots the price of both coins over the train and test sets 
  plot_prices <- ggplot(df_plot_a, aes(x = date_time)) + 
    geom_line(aes(y = coin_y_price / df_index[["coin_y_price"]], colour = "Coin Y"), size = 0.5, alpha = 0.5) + 
    geom_line(aes(y = coin_x_price / df_index[["coin_x_price"]], colour = "Coin X"), size = 0.5, alpha = 0.5) + 
    geom_vline(data = df_dates %>% filter(source == "train"), mapping = aes(xintercept = end)) + 
    scale_colour_manual(name = "Prices", labels = c(coin_x, coin_y), values = c("darkgreen", "darkred")) + 
    labs(subtitle = str_c(coin_y, " and ", coin_x), x = "Date", y = "Indexed Prices")

  # This plot plots the spread z-score and signal 
  plot_signal <- ggplot(df_plot_b, aes(x = date_time)) + 
    geom_line(aes(y = spread_z, colour = "Spread Z"), size = 1) + 
    geom_line(aes(y = signal, colour = "Signal"), size = 0.5) + 
    geom_hline(yintercept = 0, colour = "red", alpha = 0.5) + 
    geom_hline(yintercept = 2, colour = "red", alpha = 0.5) + 
    geom_hline(yintercept = -2, colour = "red", alpha = 0.5) + 
    scale_color_manual(name = "Series", values = c("Spread Z" = "blue", "Signal" = "green")) + 
    labs(subtitle = str_c(coin_y, " and ", coin_x), x = "Date", y = "Spread and Signal")
  
  # This plot plots the return of the strategy versus the buy-and-hold return of each coin 
  plot_return <- ggplot(df_plot_b, aes(x = date_time)) + 
    geom_line(aes(y = return_pair, colour = "Model"), size = 1) + 
    geom_line(aes(y = return_buyhold_y, colour = coin_y), size = 0.5, alpha = 0.4) + 
    geom_line(aes(y = return_buyhold_x, colour = coin_x), size = 0.5, alpha = 0.4) + 
    geom_hline(yintercept = 1, colour = "black") + 
    scale_colour_manual(name = "Return", labels = c(coin_x, coin_y, "Model"), values = c("darkgreen", "darkred", "darkblue")) + 
    labs(subtitle = str_c(coin_y, " and ", coin_x), x = "Date", y = "Cumulative Return")
  
  # This plot plots the intercept and hedge ratio over the test set 
  plot_coefficients <- ggplot(df_plot_c, aes(x = date_time)) + 
    geom_line(aes(y = value, colour = parameter), size = 1) + 
    facet_wrap(~ parameter, ncol = 1, scales = "free_y") + 
    labs(subtitle = str_c(coin_y, " and ", coin_x), x = "Date", y = "Value", colour = "Parameter")
  
  # This plot plots the distribution of returns for the model, coin y, and coin x
  plot_distribution <- ggplot(df_plot_d) +  
    geom_histogram(aes(x = coin_y_return, fill = coin_y), alpha = 0.2, binwidth = 0.0005) + 
    geom_histogram(aes(x = coin_x_return, fill = coin_x), alpha = 0.2, binwidth = 0.0005) + 
    geom_histogram(aes(x = combined_return, fill = "Model"), alpha = 0.5, binwidth = 0.0005) + 
    geom_vline(xintercept = 0, alpha = 0.5) + 
    coord_cartesian(xlim = c(-0.025, 0.025)) + 
    scale_fill_manual(name = "Return", labels = c(coin_x, coin_y, "Model"), values = c("darkgreen", "darkred", "darkblue")) + 
    labs(subtitle = label_subtitle, x = "Return", y = "Count")
  
  # if print is TRUE, print the plots. This option is used when rendering notebooks. 
  if (print == TRUE) {
    print(plot_prices)
    print(plot_signal)
    print(plot_return)
    print(plot_coefficients)
    print(plot_distribution)
  }
  
  # If print if false, return the plots in a list. This option is used for the shiny app. 
  if (print == FALSE) { 
    list(plot_prices = plot_prices, 
         plot_signal = plot_signal, 
         plot_return = plot_return, 
         plot_coefficients = plot_coefficients, 
         plot_distribution = plot_distribution)
  }
} 

#' # 3. Plot Many Function 
#' Description  
#' Create many plots by calling the plot_single() function multiple times. Also creates a plot showing the results of the 
#' overall strategy using backtest_strateg(). Creates a train and test set surrounding a cutoff date and creates plot for 
#' the top n coins ranked by their ADF statistic. 
#' 
#' Arguments   
#' pricing_data: A dataframe containing pricing data from Poloneix gathered in tidy format.  
#' cutoff_date: A data representing the cutoff date between the train and test sets.  
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy.  
#'   time_resolution: The number of seconds that each observation spans. Takes values 300, 900, 1800, 7200, 14400, and 86400.  
#' number_pairs: The number of pairs to generate plots for.  
#' 
#' Value  
#' Prints the plots described above.  
plot_many <- function(pricing_data, cutoff_date, params, number_pairs) { 
  
  # Create train, test, and selected coin pairs 
  setup <- setup_strategy(pricing_data = pricing_data, 
                          cutoff_date = cutoff_date, 
                          params = params) 
  train <- setup[["train"]]
  test <- setup[["test"]]
  selected_pairs <- setup[["selected_pairs"]] 
  
  # Create no plots if no coin pairs are selected 
  if (nrow(selected_pairs) == 0) 
    return("No coin pairs selected.")
  
  # For each coin pair, generate plots by calling plot_single()
  print(selected_pairs) 
  for (i in 1:min(number_pairs, nrow(selected_pairs))) { 
    cutoff_date <- as.Date(cutoff_date) 
    print(str_c("Creating plots for ", selected_pairs[["coin_y"]][i], " and ", selected_pairs[["coin_x"]][i], ".")) 
    print(str_c("Using train set from ", cutoff_date - params[["train_window"]] , " to ", cutoff_date, ".")) 
    print(str_c("Using test set from ", cutoff_date, " to ", cutoff_date + params[["test_window"]], "."))  
    plot_single(train = train, 
                test = test, 
                coin_y = selected_pairs[["coin_y"]][i], 
                coin_x = selected_pairs[["coin_x"]][i], 
                params = params, 
                print = TRUE)
  } 
  
  # Calculate overall return of strategy over this single test set and plot the cumulative return 
  print("Creating plot for overall strategy.")
  df_strategy <- backtest_strategy(train = train, 
                                   test = test, 
                                   selected_pairs = selected_pairs, 
                                   params = params)
  return_strategy <- calculate_return(df_strategy = df_strategy, 
                                      params = params)
  test <- test %>% mutate(return_strategy = return_strategy[["cumulative_return"]])
  
  # This plot plots the overall return of the strategy versus the buy-and-hold return of USDT_BTC
  # If the param set uses BTC as the quote currency, plot the return of the strategy in both USD and BTC terms
  if(params[["quote_currency"]] == "USDT") { 
    plot_strategy <- ggplot(test, aes(x = date_time)) +
      geom_line(aes(y = return_strategy, colour = "Strategy"), size = 1) +
      geom_line(aes(y = USDT_BTC / USDT_BTC[1], colour = "USDT_BTC"), size = 0.5, alpha = 0.4) +
      geom_hline(yintercept = 1, colour = "black") +
      scale_color_manual(name = "Return", values = c("Strategy" = "darkblue", "USDT_BTC" = "darkred")) +
      labs(title = "Strategy Return vs Buy Hold Return", x = "Date", y = "Cumulative Return")
  }
  if(params[["quote_currency"]] == "BTC") { 
    test <- test %>% 
      mutate(return_USDT_BTC = USDT_BTC / USDT_BTC[1], 
             return_strategy_USD = return_strategy * return_USDT_BTC)
    plot_strategy <- ggplot(test, aes(x = date_time)) +
      geom_line(aes(y = return_strategy, colour = "Strategy in BTC"), size = 1) + 
      geom_line(aes(y = return_strategy_USD, colour = "Strategy in USD"), size = 1) + 
      geom_line(aes(y = return_USDT_BTC, colour = "USDT_BTC in USD"), size = 0.5, alpha = 0.4) +
      geom_hline(yintercept = 1, colour = "black") +
      scale_color_manual(name = "Return", values = c("Strategy in BTC" = "gray", "Strategy in USD" = "darkblue", 
        "USDT_BTC in USD" = "darkred")) +
      labs(title = "Strategy Return vs Buy Hold Return", x = "Date", y = "Cumulative Return")
  }
  
  # Print the plot
  print(plot_strategy)
  
} 

