#' ---
#' title: "Backtesting Functions"
#' author: "Kevin Lu"
#' date: '`r format(Sys.Date(), "%B %d, %Y")`'
#' output: 
#'   html_document: 
#'     theme: default 
#'     highlight: tango
#'     toc: true 
#'     toc_float: true
#'     number_sections: false
#'     fig_width: 8 
#'     fig_height: 5 
#' --- 

#' # 1. Load Packages 
source("./src/01-load-packages.R") 

#' # 2. Backtest Pair Function 
#' Description  
#' Calculate the return of a cointegration-based mean reversion trading strategy using coin y and coin x. 
#' 
#' The current backtesting logic uses a model generated by train_model() and trading signals generated by 
#' generate_signals(). The coin_y_return and coin_x_return indicate the one period percentage return of 
#' each coin. The coin_y_position and coin_x_position indicate the market value in USD in each coin. 
#' coin_y_pnl and coin_x_pnl indicate the USD value of the profit and loss for each coin. The combined_position 
#' indicates the gross market value of the combined positions. The return is calculated relative to the maximum 
#' capital allocation to the given coin pair.  
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pair.  
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pair.  
#' coin_y: A string indicating the dependent coin in the coin pair regression.  
#' coin_x: A string indicating the independent coin in the coin pair regression.  
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy.  
#'   model_type: A string indicating whether raw prices or log prices should be used. Takes value "raw" or "log".  
#'   return_calc: A string indicating the position calculation used in calculating the return of the strategy. Can take values 
#'     maximum or actual which refer to setting the denominator in the return calculation to the maximum capital allocation 
#'     to the strategy or the actual amount that was used at the time.  
#' 
#' Value  
#' Returns a dataframe containing the cumulative return of applying the trading strategy to the given coin pair 
#' with other information necessary to backtest the strategy. 
backtest_pair <- function(train, test, coin_y, coin_x, params) {  
  
  # Generate model for calculating spread z-score 
  model <- train_model(train = train, 
                       test = test, 
                       coin_y = coin_y, 
                       coin_x = coin_x, 
                       params = params)
  
  # Generate signals, prepare model objects, and calculate coin_y and coin_x return 
  test <- test %>% 
    mutate(signal = generate_signals(train = train, 
                                     test = test, 
                                     coin_y = coin_y, 
                                     coin_x = coin_x, 
                                     model = model, 
                                     params = params), 
           hedge_ratio = model[["hedge_ratio"]], 
           intercept = model[["intercept"]], 
           spread_z = model[["spread_z"]], 
           coin_y_return = test[[coin_y]] / lag(test[[coin_y]], 1) - 1, 
           coin_x_return = test[[coin_x]] / lag(test[[coin_x]], 1) - 1)
  
  # Position calculations if model uses raw or log prices. 
  if (params[["model_type"]] == "raw") { 
    test <- test %>% 
      mutate(coin_y_position = test[[coin_y]] * signal * 1           *  1, 
             coin_x_position = test[[coin_x]] * signal * hedge_ratio * -1)
  } 
  if (params[["model_type"]] == "log") { 
    test <- test %>% 
      mutate(coin_y_position = signal * 1           *  1, 
             coin_x_position = signal * hedge_ratio * -1)
  } 
  
  # Profit and loss calculation 
  test <- test %>% 
    mutate(change_y_position = coin_y_position - lag(coin_y_position, 1) - lag(coin_y_position, 1) * coin_y_return, 
           change_x_position = coin_x_position - lag(coin_x_position, 1) - lag(coin_x_position, 1) * coin_x_return, 
           coin_y_pnl = lag(coin_y_position, 1) * coin_y_return, 
           coin_x_pnl = lag(coin_x_position, 1) * coin_x_return,
           combined_pnl = coin_y_pnl + coin_x_pnl) 
  
  # Return calculation if model type uses raw or log prices and the return calculation uses maximum or actual capital
  if (params[["model_type"]] == "raw" & params[["return_calc"]] == "actual") { 
    test <- test %>% 
      mutate(combined_position = abs(coin_y_position) + abs(coin_x_position), 
             combined_return = combined_pnl / lag(combined_position, 1))
  }
  if (params[["model_type"]] == "raw" & params[["return_calc"]] == "maximum") { 
    test <- test %>% 
      mutate(combined_position = abs(test[[coin_y]]) + abs(test[[coin_x]] * hedge_ratio), 
             combined_return = combined_pnl / lag(combined_position, 1))
  }
  if (params[["model_type"]] == "log" & params[["return_calc"]] == "actual") { 
    test <- test %> %
      mutate(combined_position = abs(coin_y_position) + abs(coin_x_position), 
             combined_return = combined_pnl / lag(combined_position, 1))
  }
  if (params[["model_type"]] == "log" & params[["return_calc"]] == "maximum") { 
    test <- test %>%
      mutate(combined_position = 1 + abs(hedge_ratio), 
             combined_return = combined_pnl / lag(combined_position, 1))
  }

  # Calculate cumulative return 
  test <- test %>% 
    mutate_all(funs(ifelse(is.na(.), 0, .))) %>% 
    mutate(cumulative_return = cumprod(1 + combined_return), 
           date_time = as.POSIXct(date_time, origin = "1970-01-01")) 
  
  # Add training observations, add additional columns, and clean the dataframe 
  df_backtest <- bind_rows(train %>% mutate(source = "train"), test %>% mutate(source = "test")) %>% 
    mutate(coin_y_name = coin_y, 
           coin_x_name = coin_x, 
           coin_y_price = .[[coin_y]], 
           coin_x_price = .[[coin_x]]) %>%  
    select(-starts_with("BTC"), -starts_with("USDT")) %>% 
    select(date_unix, date_time, coin_y_name, coin_x_name, coin_y_price, coin_x_price, everything())
  
  # Return dataframe 
  return(df_backtest) 
} 

#' # 3. Backtest Strategy Function 
#' Description  
#' Calculate the return of a cointegration-based mean reversion trading strategy. The cumulative return of each 
#' coin pair is calculated. The backtest evaluates the performance over a single test set. 
#' 
#' Arguments  
#' train: A dataframe generated by prepare_data() that represents the training set for the coin pairs.  
#' test: A dataframe generated by prepare_data() that represents the test set for the coin pairs.  
#' selected_pairs: A dataframe generated by select_coins() that represents a set of cointegrated coin pairs.   
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy. 
#'   pair_allocation: A string indicating whether the capital allocation to the coin pairs should be equal or weighted. 
#'     Takes values "equal", "weighted", or "scaled".  
#'   pair_allocation_scaling: A double indicating the volatility scaling applied to the cointegration stat when the pair 
#'     allocation is scaled.  
#'   cointegration_test: A string indicating whether the Engle-Granger method or distance method is used to test for 
#'     cointegration. Takes values "eg" or "distance". 
#'     
#' Value  
#' A dataframe containing the return series of the trading strategy for each coin pair in a given train and test split 
#' along with other information necessary to backtest the strategy.   
backtest_strategy <- function(train, test, selected_pairs, params) { 
  
  # Return empty tibble if no pairs are selected 
  if (nrow(selected_pairs) == 0) 
    return(tibble()) 
  
  # Iterate through each coin pair and calculate the return of the strategy on a coin pair 
  df_strategy <- tibble()  
  for (i in 1:nrow(selected_pairs)) { 
    single_pair <- backtest_pair(train = train, 
                                 test = test, 
                                 coin_y = selected_pairs[["coin_y"]][i], 
                                 coin_x = selected_pairs[["coin_x"]][i], 
                                 params = params) %>% 
      mutate(coin_pair_id = i, 
             cointegration_stat = selected_pairs[["cointegration_stat"]][i])
    df_strategy <- bind_rows(df_strategy, single_pair)
  } 
  
  # Return dataframe 
  return(df_strategy)
}

#' # 4. Calculate Strategy Return
#' Description  
#' Calculates the return of the overall strategy over the test set allowing for various capital allocation options to 
#' each coin pair.  
#' 
#' Arguments  
#' df_strategy: A dataframe generated by backtest_strategy() that contains the return series of trading strategy for 
#' each coin pair.  
#' 
#' Value  
#' A vector containing the return series of the overall strategy over the test set.  
calculate_return <- function(df_strategy, params) { 
  
  # If no coin pairs were selected, return an empty tibble 
  if (nrow(df_strategy) == 0) { 
    return(tibble())
  }
  
  # Limit the dataframe to just the test set 
  df_strategy <- df_strategy %>% 
    filter(source == "test") 
  
  # Calculate return of the strategy applied to a portfolio of coin pairs assuming equal capital allocation 
  # to each coin pair 
  if (params[["pair_allocation"]] == "equal") { 
    df_strategy <- df_strategy %>% 
      group_by(date_time) %>% 
      summarise(cumulative_return = mean(cumulative_return)) 
  } 
  
  # Calculate return of the strategy applied to a portfolio of coin pairs assuming weighted capital allocation 
  # to each coin pair as a function of the cointegration stat 
  if (params[["pair_allocation"]] == "weighted") { 
    
    # Calculate weights if cointegration test used Engle-Grange method or total least squares  
    if (params[["cointegration_test"]] == "eg" | params[["cointegration_test"]] == "tls") { 
      df_strategy <- df_strategy %>% 
        mutate(weight = abs(cointegration_stat))
    }
    
    # Calculate weights if cointegration test used distance method 
    if (params[["cointegration_test"]] == "distance") { 
      df_strategy <- df_strategy %>% 
        mutate(weight = 1 / cointegration_stat)
    } 
    
    # Calculate weighted average of the strategy return 
    df_strategy <- df_strategy %>% 
      group_by(date_time) %>% 
      summarise(cumulative_return = weighted.mean(x = cumulative_return, w = weight)) 
  } 
  
  # Calculate return of the strategy applied to a portfolio of coin pairs assuming weighted capital allocation 
  # to each coin using a scaled tuning parameter 
  if (params[["pair_allocation"]] == "scaled") { 
    
    # Calculate weights if cointegration test used Engle-Grange method or total least squares method  
    if (params[["cointegration_test"]] == "eg" | params[["cointegration_test"]] == "tls") { 
      df_strategy <- df_strategy %>% 
        mutate(cointegration_stat_scaled = abs(cointegration_stat) ^ params[["pair_allocation_scaling"]], 
               weight = cointegration_stat_scaled) %>% 
        group_by(date_time) %>% 
        summarise(cumulative_return = weighted.mean(x = cumulative_return, w = weight))
    } 
    
    # Calculate weights if cointegration test used distance method 
    if (params[["cointegration_test"]] == "distance") { 
      df_strategy <- df_strategy %>% 
        mutate(cointegration_stat_scaled = cointegration_stat ^ params[["pair_allocation_scaling"]], 
               weight = 1 / cointegration_stat_scaled) %>% 
        group_by(date_time) %>% 
        summarise(cumulative_return = weighted.mean(x = cumulative_return, w = weight))
    }
  } 
  
  # Return the strategy return 
  return(df_strategy)
}

#' # 5. Backtest Strategy Full Function 
#' Description  
#' Calculate the return of a cointegration-based mean reversion trading strategy using a portfolio of cointegrated coin 
#' pairs. The backtest evaluates the performance in a timeseries cross validation method in which train and test sets 
#' are created iteratively over time.  
#' 
#' Arguments  
#' pricing_data: A dataframe containing pricing data from Poloneix gathered in tidy format.  
#' params: A list of parameters passed to the functions below that describe the mean reversion pairs trading strategy.  
#'   time_resolution: The number of seconds that each observation spans. Takes values 300, 900, 1800, 7200, 14400, and 86400.  
#'   train_window: A period object from lubridate representing the length of time the train set covers.  
#'   test_window: A period object from lubridate representing the length of time the the test set covers. 
#' 
#' Value   
#' A dataframe containing the cumulative return of the overall trading strategy calculated in using a timeseries 
#' cross validation method. 
backtest_strategy_full <- function(pricing_data, params) { 
  
  # Create vector of cutoff dates for train and test sets over time using a time series cross validation approach 
  cutoff_dates <- seq(ymd("2017-01-01"), ymd("2017-10-01"), by = str_c(day(params[["test_window"]]), " days"))
  
  # Iterate through each cutoff date and calculate the strategy return for each test set 
  results <- tibble() 
  for (cutoff_date in cutoff_dates) {  
    
    # Print dates that train and test sets cover 
    cutoff_date <- as.Date(cutoff_date) 
    print(str_c("Cross validating strategy."))
    print(str_c("Using train set from ", cutoff_date - params[["train_window"]] , " to ", cutoff_date, ".")) 
    print(str_c("Using test set from ", cutoff_date, " to ", cutoff_date + params[["test_window"]], "."))  
    
    # Create train, test, and selected coin pairs 
    setup <- setup_strategy(pricing_data = pricing_data, 
                            cutoff_date = cutoff_date, 
                            params = params) 
    train <- setup[["train"]]
    test <- setup[["test"]]
    selected_pairs <- setup[["selected_pairs"]]
    
    # Calculate strategy return over single test set 
    df_strategy <- backtest_strategy(train = train, 
                                     test = test, 
                                     selected_pairs = selected_pairs, 
                                     params = params)
    return_strategy <- calculate_return(df_strategy = df_strategy, 
                                        params = params)
    
    # Calculate the change in the cumulative return over the test set with error handling if no coin pairs are selected 
    if (nrow(return_strategy) != 0 ) { 
      return_strategy <- return_strategy %>% 
        mutate(cumulative_return_change = cumulative_return / lag(cumulative_return, 1) - 1) %>% 
        mutate_all(funs(ifelse(is.na(.), 0, .)))
    }

    # Append results
    results <- bind_rows(results, return_strategy) 
  } 
  
  # Calculate strategy return using all test sets 
  results <- results %>% 
    mutate(return_strategy_cumulative = cumprod(1 + cumulative_return_change), 
           date_time = as.POSIXct(date_time, origin = "1970-01-01")) %>% 
    select(date_time, return_strategy_cumulative)
  
  # Return results 
  return(results)
} 

